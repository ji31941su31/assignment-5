# -*- coding: utf-8 -*-
"""assignment 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jHwzUCXn-a35G0ydBe7LePYwK4j58lFe
"""

import numpy as np
from scipy.special import ndtri
import matplotlib.pyplot as plt

class SignalDetection:
    def __init__(self, hits, misses, false_alarms, correct_rejections):
        self.__hits = hits
        self.__misses = misses
        self.__false_alarms = false_alarms
        self.__correct_rejections = correct_rejections
    
    def hit_rate(self):
        return (self.__hits / (self.__hits + self.__misses))

    def false_alarm_rate(self):
        return (self.__false_alarms / (self.__false_alarms + self.__correct_rejections))

    def d_prime(self):
        return (ndtri(self.hit_rate()) - ndtri(self.false_alarm_rate()))

    def criterion(self):
        return -0.5 * (ndtri(self.hit_rate()) + ndtri(self.false_alarm_rate()))

    def __add__(self, other):
        return SignalDetection(self.__hits + other.__hits, self.__misses + other.__misses, self.__false_alarms + other.__false_alarms, self.__correct_rejections + other.__correct_rejections)

    def __mul__(self, scalar):
        return SignalDetection(self.__hits * scalar, self.__misses * scalar, self.__false_alarms * scalar, self.__correct_rejections * scalar)

    def plot_roc(self):
        point = [self.false_alarm_rate(), self.hit_rate()]
        begin = [0,0]
        target = [1,1]
        plt.plot(self.false_alarm_rate(), self.hit_rate(), marker = 'o')
        line_x1 = [begin[0],point[0]]
        line_x2 = [point[0],target[0]]
        line_y1 = [begin[1],point[1]]
        line_y2 = [point[1],target[1]]
        plt.plot(line_x1,line_y1)
        plt.plot(line_x2,line_y2)
        plt.plot([0,1],'--')
        plt.xlim([0,1])
        plt.ylim([0,1])
        plt.show()

    def plot_sdt(self):
        d = SignalDetection.d_prime(self)
        criterion = self.criterion()
        x = np.linspace(-6,6,100)
        plt.plot(x, norm.pdf(x, 0, 1),label = 'noise')
        plt.plot(x, norm.pdf(x, -d, 1), label = 'signal')
        plt.axvline(x = criterion, label = 'criterion')
        plt.title('Noise vs. Signal distribution')
        plt.legend()
        plt.show()

    def nLogLikelihood(self, hitRate, falseAlarmRate):
        hits = self.__hits
        misses = self.__misses
        false_alarms = self.__false_alarms
        correct_rejections = self.__correct_rejections

        pHit = hitRate
        pMiss = 1 - pHit
        pFA = falseAlarmRate
        pCR = 1 - pFA
        llh = -(hits * np.log(pHit) + misses * np.log(pMiss) + false_alarms * np.log(pFA) + correct_rejections * np.log(pCR))

        return llh

    def rocCurve(self, falseAlarmRate, a):
        truePositiveRate = 1 - ndtri(falseAlarmRate)
def fit_roc(sdtList):

        hits = [s.hit_rate() for s in sdtList]
        false_alarms = [s.false_alarm_rate() for s in sdtList]

        def loss(alpha):
            roc_curve = [SignalDetection.roc_curve(fa, alpha) for fa in false_alarms]
            return np.sum((np.array(hits) - np.array(roc_curve)) ** 2)

        result = minimize_scalar(loss, method='bounded', bounds=(0, 10))

        plt.figure()
        for s in sdtList:
            s.plot_roc()
        alpha = result.x
        false_alarms_fit = np.linspace(0, 1, 100)
        true_positives_fit = [SignalDetection.roc_curve(fa, alpha) for fa in false_alarms_fit]
        plt.plot(false_alarms_fit, true_positives_fit, label=f'alpha={alpha:.2f}')
        plt.legend()
        plt.show()
    
    def roc_curve(false_alarm_rate, alpha):
        true_positive_rate = (1 - ndtri(false_alarm_rate)) / alpha
        return true_positive_rate